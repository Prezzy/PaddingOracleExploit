#include <cstdlib>
#include <cstdio>
#include <cerrno>

#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/prctl.h>
#include <signal.h>
#include <error.h>

#include "constants.h"

int main(int argc, char * argv[])
{
	int status;
	ssize_t bytes_read, bytes_written;

	// read the ciphertext from a file
	unsigned char buf[IVLEN + MACLEN + CTLEN] = { '\0' };
	int ctfd =  open(CTFILE, O_RDONLY);
	if (ctfd == -1) error(1, errno, "opening %s", CTFILE);
	bytes_read = read(ctfd, buf, IVLEN + MACLEN + CTLEN);
	if (bytes_read <= IVLEN + MACLEN) error(1, errno, "ciphertext too short");
	close(ctfd);

	// create some pipes for directional communication with the child process
	int ifd[2], ofd[2];
	if (pipe(ifd) != 0) error(1, errno, "creating input pipe");
	if (pipe(ofd) != 0) error(1, errno, "creating output pipe");

	// loop till we're done...
	bool done = false;
	while (!done)
	{
		pid_t pid = fork();

		if (pid == 0)
		{
			// this is the child; it will simply exec into our desired
			// oracle program, but first it replaces stdin and stdout with
			// the above-created pipes so that the parent can both write to
			// and read from it
			dup2(ofd[0], STDIN_FILENO);
			dup2(ifd[1], STDOUT_FILENO);

			// ask kernel to deliver SIGTERM in case the parent dies
			prctl(PR_SET_PDEATHSIG, SIGTERM);

			// run the oracle
			execl(ORACLE, ORACLE, (char *)NULL);
			// we'll never get here, unless execl fails for some reason
			exit(1);
		}
		else
		{
			// this is the parent; you can write to and read from the child
			// via ofd[1] and ifd[0], respectively

			// write the ciphertext
			write(ofd[1], &bytes_read, sizeof(bytes_read));
			bytes_written = write(ofd[1], buf, bytes_read);
			fprintf(stderr, "Wrote %lu bytes\n", bytes_written);

			// read the 1-byte respond (see constants.h for interpretations)
			unsigned char result = 0;
			bytes_read = read(ifd[0], &result, 1);
			fprintf(stderr, "Oracle returned: %c\n", result);

			// wait for child to exit
			waitpid(pid, &status, 0);
			done = true; // break out of the while loop
		}
	}

	close(ofd[0]);
	close(ofd[1]);
	close(ifd[0]);
	close(ifd[1]);

	return 0;
}
